# 15장 구글 드라이브 설계

## 요구사항 정의

### 기능적 요구사항

- 파일 추가, 가장 쉬운 방법은 드래그 앤 드랍

- 파일 다운로드

- 여러 단말에 파일 동기화, 모바일 앱에서 업로드 하면 웹에서도 자동으로 동기화 되어야 한다.

- 파일 갱신 이력 조회

- 파일 공유

- 파일이 편집되거나 삭제되거나 새롭게 공유되었을 때 알림 표시

### 비-기능적 요구사항

- 안정성 : 데이터 손실 발생하면 안됨

- 빠른 동기화 속도 : 동기화에 시간이 오래 소요되면 안됨

- 네트워크 대역폭 : 이 제품이 네트워크 대역폭을 많이 소비하면 안됨 (특히 모바일 사용자의 경우라면 더욱)

- 규모 확장성 : 아주 많은 양의 트래픽도 처리 가능해야 한다.

- 높은 가용성 : 일부 장애 발생,느려지거나, 네트워크 일부가 끊겨도 시스템은 계속 사용 가능해야 한다.

<br />
<br />

## API

이 시스템은 어떤 API 필요할까?

기본적으로 세 가지 API가 필요하다. 파일 업로드 API, 다운로드 API, 그리고 파일 갱신 히스토리 제공 API 이다.

<br />

## 파일 업로드 API

이 시스템은 두 가지 종류의 업로드를 지원한다.

- 단순 업로드 : 파일 크기가 작을때 사용한다.
- 이어 올리기(resumable upload) : 파일 사이즈가 크고 네트워크 문제로 업로드가 중단될 가능성이 높다고 생각되면 사용한다.

### 이어올리기 API의 예

```
  https://api.example.com/files/upload?uploadType=resumable
```

### 인자

- uploadType=resumable
- data: 업로드할 로컬 파일

이어 올리기는 다음 세 단계 절차로 이루어 진다.

- 이어 올리기 URL을 받기 위한 최초 요청 전송
- 데이터를 업로드하고 업로드 상태 모니터링
- 업로드에 장애가 발생하면 장애 발생시점부터 업로드를 재시작

<br />
<br />
<br />

## 파일 다운로드 API

```
  https://api.example.com/files/download
```

### 인자

- path : 다운로드 할 파일의 경로

```
{
  "path": "/recipes/soup/best_soup.txt"
}
```

<br />
<br />
<br />

## 파일 갱신 히스토리 API

```
  https://api.example.com/files/list_revisions
```

### 인자

- path : 갱신 히스토리를 가져올 파일의 경로
- limit : 히스토리 길이의 최대치

```
  {
    "path": "/recipes/soup/best_soup.txt",
    "limit": 20
  }
```

위 API는 모두 사용자 인증을 필요로하고 HTTPS 프로토콜을 사용해야 한다.

SSL을 지원하는 프로토콜을 사용하는 이유는 주고받는 데이터를 보호하기 위한 것이다.

<br />
<br />
<br />

## 동기화 충돌

두명 이상의 사용자가 같은 파일이나 폴더를 동시에 업데이트하려고 하는 경우는 어떻게 해야 할까?

사용자1과 사용자2중 먼저 처리한 쪽을 정상적인 갱신 처리로 하고, 다른쪽에 대해서는 충돌 오류로 판단한다.

<br />
<br />
<br />

## 전체 설계도

![image (1)](https://user-images.githubusercontent.com/103870198/216818842-e04e3ed6-f3c4-4ce6-834f-285b8ca100e6.png)

- 단말 : 사용자가 이용하는 브라우저, 모바일앱

- 블록 저장소 서버 :

  파일 블록을 클라우드 저장소에 업로드하는 서버이다.

  이 저장소는 파일을 여러개의 블록으로 나눠 저장하며,

  각 블록에는 고유한 해시값이 할당된다.(해시값은 메타데이터 DB에 저장)

  각 블록은 독립적인 객체로 취급되며 파일의 재구성을 위해서는 블록들을 원래 순서대로 합쳐야 한다.

- 클라우드 저장소 : 파일은 블록 단위로 나누어져 클라우드 저장소에 보관 된다.

- 아키이빙 저장소 : 장기간 미사용 데이터를 저장하기 위함

- 로드밸런서 : 요청을 모든 API 서버에 고르게 분산한다.

- API 서버 : 파일 업로드 외에 모든것을 담당

- 메타데이터 DB : 사용자, 파일, 블록, 버전 등의 메타데이터 정보를 관리한다.

- 메타데이터 캐시 : 자주 쓰이는 메타데이터는 캐시한다.

- 알림 서비스 : 파일 추가,편집,삭제 시 클라이언트에게 알림

- 오프라인 사용자 백업 큐 : 클라이언트가 접속했을때 최신 상태 파일을 동기화하기 위한 큐

<br />

## 블록 저장소 서버

정기적으로 갱신되는 큰 파일들은 업데이트가 일어날 때마다 전체 파일을 서버로 보내면 네트워크 대역폭을 많이 잡아먹게 된다.

이를 최적화 하는 방법으로 두 가지 정도가 있다.

- 델타 동기화(delta sync) : 파일이 수정되면 전체 파일 대신 수정이 일어난 블록만 동기화하는 것
- 압축(compression) : 블록 단위로 압축해서 데이터 크기를 많이 줄일 수 있다. 압축 알고리즘은 유형에 따라 정한다.

이 시스템에서 블록 저장소 서버는 파일 업로드에 관한 힘든 일을 처리하는 컴포넌트이다. 다음과 같은 과정으로 동작한다.

- 주어진 파일을 작은 블록들로 분할한다.
- 각 블록을 압축한다.
- 클라우드 저장소로 보내기 전에 암호화한다.
- 클라우드 저장소로 보낸다.

<br />
<br />

## 높은 일관성 요구사항

이 시스템은 강한 일관성 모델을 기본으로 지원해야 한다.

같은 파일이 사용자에 따라 다르게 보이는 것은 허용할 수 없기 때문이다.

메모리 캐시는 보통 최종 일관성을 지원한다. 강한 일관성을 달성하려면 다음 사항을 보장해야 한다.

- 캐시에 보관된 사본과 데이터베이스에 있는 원본(master)가 일치한다.
- 데이터베이스에 보관된 원본에 변경이 발생하면 캐시에 있는 사본을 무효화한다.

이 설계에서는 ACID를 기본 지원하는 관계형 데이터베이스를 채택한다.

<br />
<br />

## 알림 서비스

일관성 유지를 위해 클라이언트는 로컬에서 파일이 수정되었음을 감지하는 순간 다른 클라이언트에게 그 사실을 알려 충돌 가능성을 줄여야 한다.

다음 두가지 선택지가 있다.

- 롱 폴링(long poling) : 드롭박스가 채택한 방식
- 웹소켓(WebSocket): 클라-서버 간 양방향 통신 가능

이 책에서는 롱폴링 방식을 채택하는데

- 채팅과 달리 이 시스템의 알림은 서버 -> 클라 통신은 필요하지만 반대 케이스는 필요 없다.
- 구글 드라이브의 경우 알림을 보낼 일이 자주 발생하지 않으며, 보내야 하는 경우에도 단시간에 많은 양의 데이터를 보낼 일은 없다.

<br />
<br />

## 저장소 공간 절약

파일 갱신 이력을 보존하고 안정성을 보장하기 위해서는 파일의 여러 버전을 여러 데이터센터에 보관할 필요가 있다.

모든 버전을 다 백업하면 저장소가 빨리 소진되므로 아래 세 가지 방법을 고려하자.

- 중복 제거(de-dupe) : 중복된 파일 블록을 계정 차원에서 제거하는 방법, 두 블록이 같은지는 해시값을 비교해서 판단한다.

- 지능적 백업 전략 도입

  - 한도 설정 : 보관해야 하는 파일 버전 개수를 설정하는 것
  - 중요한 버전만 보관

- 자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮긴다.
