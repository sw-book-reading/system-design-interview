
# chpt11. 뉴스 피드 시스템 설계
- 뉴스 피드
	- 사용자의 홈페이지 중앙에 지속적으로 업데이트 되는 스토리들


### News Feed publishing
![](attatchments/스크린샷%202023-01-29%20오전%209.53.04.png)
- post service 
	- 새 포스팅을 cache, db에 저장
- fanout service
	- 새 포스팅을 친구의 news feed에 push.
	- 새 포스팅을 cache 에 보관하여 친구가 빠르게 읽어갈 수 있게 한다.
- notification service

### News Feed building
![](attatchments/스크린샷%202023-01-29%20오전%209.53.26.png)
- news feed service
	- cache 로부터 news feed 를 가져온다
- news feed cache
	- news feed 를 렌더링할 때 필요한 feed id 를 보관

---
## 상세설계
### feed publishing
![](attatchments/스크린샷%202023-01-29%20오전%209.56.57.png)
- web server
	- http header 를 통한 인증
	- 특정 사용자가 올릴 수 있는 포스팅 수 제한. rate limiting

#### fanout service models
##### fanout-on-write (push)
- 새로운 포스팅을 기록하는 시점에 뉴스 피드 갱신
- 장점
	- 뉴스피드가 실시간으로 갱신. 친구 목록에 있는 사용자에게 즉시 전송
	- 읽기 요청 이전에 뉴스피드가 갱신되어 있기 때문에 뉴스피드를 읽는데 드는 시간이 짧음
- 단점
	- 친구가 많은 사용자는 친구 목록을 가져오고 모든 친구의 뉴스 피드를 갱신하는데 많은 시간 소요. (hotkey problem)
	- 서비스를 자주 이용하지 않는 사용자의 피드까지 갱신해야 하므로 컴퓨팅 자원이 낭비됨

##### fanout-on-read (pull)
- 피드를 읽어야 하는 시점에 뉴스 피드를 갱신
- 장점
	- 비활성화된 사용자, 서비스에 거의 로그인하지 않는 사용자가 있을 때 효율적
	- 데이터를 친구 각각에 푸시하지 않으므로 hotkey problem 발생 X
		- 즉, 뉴스 피드 갱신 요청 처리까지 시간이 오래 걸리지 않는다.
- 단점
	- 뉴스피드를 읽는데 많은 시간이 소요될 수 있음

##### 절충안
- 대부분 사용자에게는 Push model 사용
- 친구가 많은 사용자에게는 Pull model 사용

### fanout service 상세

![](attatchments/스크린샷%202023-01-29%20오전%2010.21.29.png)
![](attatchments/스크린샷%202023-01-29%20오전%2010.21.40.png)
- 메시지큐, 뉴스피드 캐시에는 post_id, user_id 만 저장
	- data 전부를 저장하지 않는 이유는 메모리 요구량이 지나치게 높아질 수 있기 때문

### feed 읽기 상세
![](attatchments/스크린샷%202023-01-29%20오전%2010.24.24.png)
- 5. user_id 를 통해 user 정보를, post_id 를 통해 post 정보를 가져온 뒤 완전한 뉴스 피드를 만들어서 클라이언트에게 json 형태로 반환

### 캐시 구조

![](attatchments/스크린샷%202023-01-29%20오전%2010.26.52.png)
- Q. 194p. cache 가 계층을 이룬다는 것은 어떤 의미일까?
- Q. 여러 캐시가 등장하는데 그중 어떤 캐시를 뜻하는 걸까?


---
# chpt12. 채팅 시스템 설계
#### 클라이언트 간 메시지 송수신 : 프로토콜
- HTTP 한계
	- 클라이언트가 연결을 만드므로, 서버에서 클라이언트로 임의 시점에 메시지를 보내는 데는 쉽게 쓰일 수 없음
- 폴링
	- 클라이언트가 주기적으로 서버에게 새 메시지가 있냐고 물어보는 방법
	- 단점
		- 답해줄 메시지가 없는 경우 서버 자원 낭비
- 롱 폴링
	- 클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지 
	- 단점
		- 메시지 송신 클라이언트, 수신 클라이언트가 서로 다른 채팅서버에 접속하게될 수도 있음. (로드밸런싱)
		- 여전히 비효율적. 
		- 서버 입장에서는 클라이언트가 연결을 해제했는지 아닌지 알 수 없음
- 웹소켓
	- http 로 연결을 맺고 이후 웹소켓 연결로 업그레이드
	- 한번 맺어진 연결은 항구적이고, 양방향


### 개략적 설계

![](attatchments/스크린샷%202023-01-29%20오후%208.56.51.png)
- Service discovery
	- 클라이언트가 접속할 채팅 서버의 DNS host 명을 클라이언트에게 알려줌
		- 채팅 서버 선택 기준
			- 클라이언트의 위치, 서버 용량 등
		- zookeeper 사용 추천
		- Q. 211p. 채팅서버를 한번 고르고 나면 사용자는 다음에 접속할 때는 이 채팅서버로만 요청을 보내게 되는 것인가..? 채팅서비스는 stateful 해야 하는데..?
	

![](attatchments/스크린샷%202023-01-29%20오후%208.58.11.png)
- 저장소
	- 데이터 분류
		- 일반적인 데이터
			- e.g. 사용자 프로필, 설정, 친구목록 등
			- 안정성을 보장하는 관계형 DB에 저장
		- 채팅 이력
			- 데이터 양이 많음
			- 최근에 주고받은 메시지만 빈번히 조회
			- NoSQL 중 Key-value 저장소 추천
				- 수평적 규모확장 쉬움
				- 데이터 접근 지연시간 낮음
				- 관계형 DB 는 long tail 에 해당하는 부분을 잘 처리하지 못하는 경향
				- Q. long tail..?

### 메시지 처리 흐름
#### 1:1 채팅
![](attatchments/스크린샷%202023-01-29%20오후%209.08.20.png)

#### 소규모 그룹 채팅
![](attatchments/스크린샷%202023-01-29%20오후%209.37.18.png)
- User A 가 보낸 메시지가 사용자 B, C 의 큐로 복사된다. 
- 그룹이 크지 않으면 메시지를 수신자 별로 복사해서 큐에 넣는 작업의 비용이 크지 않음

#### 수신자 관점에서 메시지 흐름
![](attatchments/스크린샷%202023-01-29%20오후%209.39.04.png)

### 접속상태 표시
- 접속상태 서버 또한 클라이언트와 웹소켓으로 통신하는 실시간 서비스 일부
![](attatchments/스크린샷%202023-01-29%20오후%209.40.26.png)
#### User disconnection
![](attatchments/스크린샷%202023-01-29%20오후%209.41.12.png)
- 클라이언트 -> 접속상태서버 로 주기적으로 heartbeat 를 보내도록 함.
	- 일정 시간을 초과해서 heartbeat 가 오지 않으면 연결이 끊어진 것으로 update

#### 접속상태 전파

![](attatchments/스크린샷%202023-01-29%20오후%209.44.02.png)
- Pub-sub model 사용 (그룹 크기가 작을 때)
	- 각각의 친구 관계마다 채널을 두고, 접속상태 변경 사실을 각 채널에 전송. 친구가 이를 읽어가는 형태
- 그룹 크기가 커진다면 친구가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 하거나, 사용자 접속상태를 수동으로 갱신하도록 한다.


