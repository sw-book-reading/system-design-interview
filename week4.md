# chpt9. 웹 크롤러 설계

![](attatchments/스크린샷%202023-01-20%20오전%208.30.11.png)

### 크롤러가 만족하면 좋은 속성들
- 규모 확장성
	- parallelism 활용 가능
- robustness(안정성)
	- 비정상적인 입력, 환경에 대응
- politeness
	- 수집 대상 웹사이트에 짧은 시간 동안 너무 많은 요청 X
- extensibility(확장성)
	- 새로운 형태의 콘텐츠 지원 가능

### 개략적 설계안
![](attatchments/스크린샷%202023-01-20%20오전%208.29.34.png)


- seed URLs
- URL Frontier (미수집 URL 저장소)
	- 다운로드할 URL 을 저장, 관리하는 컴포넌트 
- HTML Downloader
- DNS Resolver (도메인 이름 변환기)
- Content Parser
- Content Seen?
	- 이미 시스템에 저장된 콘텐츠인지 알아 보는 것.
	- 두 문서를 문자열로 보고 비교하는 것은 비효율적
		- 웹페이지의 해시 값을 비교하는 방법 추천
- Content storage
	- 대부분의 콘텐츠는 디스크에 저장
	- 인기있는 콘텐츠는 메모리에 저장
- Link Extractor
- URL Filter
	- deny list 에 포함된 URL, 접속시 오류가 발생하는 URL 등을 크롤링 대상에서 배제
- URL Seen?
	- 이미 방문한 URL 혹은 이미 미수집 URL 저장소에 보관된 URL 인지 확인.
	- Bloom filter 혹은 Hash table 추천
- URL Storage
	- 이미 방문한 URL 보관

![](attatchments/스크린샷%202023-01-20%20오전%209.07.36.png)


### DFS vs BFS
- DFS 는 추천 X
	- 그래프 크기가 클 경우 어느 정도로 깊숙이 가게 될지 가늠하기 어려움
- BFS
	- 문제점
		- 한 페이지에서 추출한 링크는 대부분 동일한 서버에 속하는 링크.
			- 링크를 병렬로 처리하다보면 타겟 서버는 수많은 요청으로 과부하에 걸리게 될 것.
		- URL 간 우선순위를 두지 않음 

### 미수집 URL 저장소
#### politeness
- 동일 웹사이트에 대해서는 한 번에 한 페이지만 요청
- workerThread 마다 별도의 FIFO 큐를 두어서 <hostname, workerThread> 간의 mapping 이 이루어지도록 한다.
![](attatchments/스크린샷%202023-01-20%20오전%209.16.39.png)
![](attatchments/스크린샷%202023-01-20%20오전%209.16.52.png)


#### priority
- 크롤러가 중요한 페이지를 먼저 수집하는 것이 바람직.
- 우선순위 기준 e.g. 트래픽 양, 갱신 빈도

![](attatchments/스크린샷%202023-01-20%20오전%209.18.47.png)
- priortizer
	- URL 을 입력 받아서 우선순위 계산
- Queue(f1,f2, ..., fn)
	- 우선순위별로 큐가 할당
	- 우선순위가 높으면 선택될 확률이 올라감
- Queue selector
	- 순위가 더 높은 큐에서 더 자주 꺼내도록 설계

![](attatchments/스크린샷%202023-01-20%20오전%209.20.14.png)

#### freshness
- 웹페이지가 수시로 변경되므로 데이터의 신선함을 유지하려면 이미 다운로드한 페이지라고 해도 주기적인 재수집 필요
- 전략
	- 웹페이지 변경 이력 활용
	- 우선순위를 활용하여 중요한 페이지는 좀 더 자주 재수집


---
# chpt10. 알림 시스템 설계


#### 연락처 정보 수집 
- 사용자가 계정을 등록할 때 API 서버가 사용자 정보(모바일 단말 토큰, 전화번호, 이메일 주소 등)를 DB 에 저장


#### 알림 전송 및 수신
![](attatchments/스크린샷%202023-01-22%20오후%204.36.01.png)
- Notification System
	- 알림 전송을 위한 API 제공
	- 제3자 서비스에 전달할 알람 Payload 생성
- Third Party Services
	- 확장성(Extensibility) 중요
		- 쉽게 새로운 서비스를 붙이거나 제거할 수 있어야 함
		- Q. 어떻게 하면 확장성이 좋아질까. OOP?(Interface 로 구현?)

##### 위 설계 문제점
- SPOF
	- notification system 이 단일 서버로 구성
- 규모 확장성
	- 데이터베이스, 캐시 등 중요 컴포넌트 규모를 개별적으로 늘릴 수 없음
- 성능 병목
	- 알림을 처리하고 전송하는 것은 자원이 많이 필요. 따라서 사용자 트래픽이 몰리면 시스템이 과부하 될 수 있음.

##### 개선된 설계
![](attatchments/스크린샷%202023-01-22%20오후%204.40.56.png)
- 데이터베이스, 캐시를 알림 시스템 서버와 분리
	- 데이터베이스
		- 사용자, 알림, 설정 정보 저장
	- 캐시
		- 사용자 정보, 단말 정보, 알림 템플릿 등을 캐시
- 알림 서버 증설 & 자동으로 수평적 규모 확장 가능
- 메시지 큐 사용
	- 시스템 컴포넌트 간 강결합 제거 -> 성능 병목 또한 해결?
	- 다량의 알림이 전송되어야 하는 경우를 대비한 버퍼 역할

#### 안정성
##### 데이터 손실 방지
- 어떤 상황에서도 알림이 소실되면 안됨
	- 알림 데이터를 DB 에 보관하고 재시도 매커니즘 구현
##### 알림 중복 전송 방지
- 중복 탐지 매커니즘 도입
	- e.g. 보내야할 알림이 도착하면 event ID 를 검사하여 이전에 본 적이 있는 event 인지 체크


#### 더욱 개선된 설계
![](attatchments/스크린샷%202023-01-22%20오후%204.51.44.png)
- 알림 서버에 인증(Authentication), 전송률 제한(rate-limit) 기능 추가
	- 전송률 제한 : 한 사용자가 받을 수 있는 알림 빈도를 제한
	- 인증 : 인증된 클라이언트만이 알림을 보낼 수 있게 함
- Notification template
	- 알림 생성 과정을 단순화하고 알림 내용 일관성 유지
- 모니터링, 추적 시스템 추가

