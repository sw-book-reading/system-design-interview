# [11장] 뉴스 피드 시스템 설계

- 포스팅 전송(팬아웃) 서비스
	- 쓰기 시점에 팬아웃 (push model)
		- 포스팅을 기록하는 시점에 뉴스피드를 갱신
		- 친구가 많은 사용자의 경우 시간이 많이 소요될 수 있음
		- 핫키 문제란
			- 인기 상품에 대한 요청이 너무 많이 처리되어 해당 캐시가 빈번하게 방문된다. 데이터가 같은 기계에 빈번하게 접근하여 집단 성능의 불균형을 초래하는 것
			
	- 읽기 시점에 팬아웃 (pull model)
		- 데이터를 친구 각각에 푸시하는 작업이 필요 없음, 친구가 로그인할 때만 푸시하면 되기 때문
		- 하지만 로그인 하는 시점에 뉴스피드를 요청해야 하므로, 오래동안 로그인하지 않았다면 로딩에 많은 시간이 걸릴 수 있을 것 같다
	- 효율적으로 하기 위해서는 대부분의 사람들에게는 push model 적용하고 친구나 follwer가 많은 사람의 follwer에게는 pull model 적용

- 데이터 베이스 규모 확장
	- 사례
	- SQL - Postgresql - citus
	- sharding 


# [12장] 채팅 시스템 설계

- 요구사항
	- 클라리언트로부터 메시지 수신
	- 메시지 수신자 결정 및 전달
	- 수신자가 접속 상태가 아닌경우 해당 메시지 보관

- 클라이언트가 서버로부터 메시지를 수신 받을 때 사용하는 방식
	- 폴링
		- 클라이언트가 주기적으로 서버에게 메시지가 있냐고 묻는 방식, 비효율적이고 자원 낭비
	- 롱 풀링
		- 클라이언트가 새 메시지가 반환되거나 타임 아웃 될 때까지 연결을 유지하는 방식
		- 타임아웃이 일어날 때 마다 서버에 다시 접속
		- 서버 입장에서 클라이언트가 연결을 해제했는지 알 수 없다
		- 메시지를 보내는 서버와 다른 서버가 연결될 수 있다? 
	- 웹소켓
		- 웹 버전의 TCP, 서버와 클라이언트간에 socket 연결을 유지해서 언제든 양방향 통신 가능 (stateful protocol)
		- HTTP는 request/ response 기반의 stateless protocol
		- 롱 풀링을 해도 어느정도 해결이 가능하지만, 데이터의 실시간 업데이트가 중요시되어 websocket이 선호
		- HTTP 프로토콜로 핸드 쉐이킹을 하고, Upgrade request 후 101 Switching Protocols response가 오면 전환
		- 80 또는 443 포트 그대로 사용
	- 클라이언트와 서버간의 메시지 전달을 실시간으로 하기 위해 웹소켓 사용

- 모놀리틱 서비스, 마이크로 서비스 아키텍쳐
	- 단일 코드 베이스의 APP, APP을 작은 서비스로 분할하고 각 서비스가 독립적으로 작용

- 채팅서비스는 상태를 유지해야 함, 클라이언트와 연결을 유지해야 하므로
- 서비스 탐색 기능
	- apache zookeeper, 클라이언트의 위치, 서버의 용량에 따라 최적의 채팅 서버를 선택해줌
	
- 메시지 흐름
	- 클라이언트가 채팅 서버로 메시지 전송, 메시지에 따른 ID 생성, 채팅 서버는 MQ로 작업 전송, MQ에서 DB 저장과 상대 채팅 서버에게 보냄
- 그룹 채팅 메시지 흐름
	- 사용자마다 메시지 동기화 큐가 있음, 본인의 메시지 큐만 확인하면 되므로 간단하다, 
	- 하지만 사용자가 너무 많을 경우, 똑같은 메시지를 모든 사용자의 큐에 복사하는게 부담될 수 있따?

- 접속 상태 표시
	- 하트비트를 통해 체크

- whatsapp, end-to-end encryption
	- 메시지, 사진, 비디오, 음성 메시지 등을 암호화 하여 수신자와 송신자만 전송된 내용을 알 수 있음
	- 메시지 대화 참여들만 복호화 키를 갖고 있음, 서버에서 복호화 되지 않음
	- 공개키 암호화 방식 사용
