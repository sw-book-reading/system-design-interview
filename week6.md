# chpt13. 검색어 자동완성 시스템

## 개략적 설계

### 데이터 수집 서비스
- 사용자가 입력한 질의를 실시간으로 수집.
- 개략적으로, <질의, 빈도> table 을 만들어서 관리

### 질의 서비스
- 주어진 질의에 5개의 인기 검색어를 정렬해서 내놓는 서비스
- 개략적으로, SQL 쿼리문 활용

## 상세 설계
- 개략적 설계 최적화

### 트라이 자료구조
- SQL 쿼리에서 생기는 병목 문제 해결
- 문자열을 꺼내는 연산에 초점을 맞추어 설계된 자료구조

![](attatchments/스크린샷%202023-01-31%20오전%208.31.29.png)
- 각 노드에 검색 빈도를 함께 저장

![](attatchments/스크린샷%202023-01-31%20오전%208.33.51.png)
- 'be' 를 검색했을 때 상위 2개의 인기 검색어를 찾는 예시

![](attatchments/스크린샷%202023-01-31%20오전%208.35.27.png)
- 각 노드에 5개의 인기 검색어를 캐시
	- top 5 검색어 질의 시간 복잡도를 낮출 수 있음
		- 단, 질의어 저장 공간이 많이 필요하다는 단점

### 데이터 수집 서비스
- 개략적 설계에서처럼 '실시간' 으로 데이터를 수정하는 것은 문제가 있음
	- 실시간으로 트라이 갱신하면 서비스가 현저히 느려짐
	- 인기 검색어는 그렇게 자주 바뀌지 않으므로 트라이를 자주 갱신할 필요 없음

#### 개선된 데이터 수집 서비스
![](attatchments/스크린샷%202023-01-31%20오전%208.40.29.png)


![](attatchments/스크린샷%202023-01-31%20오전%208.40.43.png)
- Anayltics Logs
	- 질의에 관한 원본 데이터 보관
- Aggregators
	- 1주일 간격으로 로그 취합
![](attatchments/스크린샷%202023-01-31%20오전%208.43.34.png)
- Aggregated Data
- Workers
	- 주기적, 비동기적으로 트라이 자료구조를 만들어서 트라이 DB 에 저장
- Trie DB
	- 문서 저장소(document store)
		- 트라이를 직렬화해서 DB 에 저장
		- e.g. mongoDB
	- 키-값 저장소
		- <접두어, 노드 데이터>
- Trie Cache
	- 매주 트라이 DB 의 스냅샷을 떠서 갱신

### 질의 서비스
#### 개선된 질의 서비스
![](attatchments/스크린샷%202023-01-31%20오전%208.47.58.png)
- SQL 대신 트라이 Cache, DB 를 조회해서 결과를 반환
- 추가 최적화 방안
	- AJAX 요청
	- 브라우저 캐싱
	- 데이터 샘플링

### 트라이 연산
- 트라이 생성
	- 작업 서버(Workers)가 담당. 로그 혹은 DB 로부터 취합된 데이터 활용
- 트라이 갱신
	- 1안) 매주 한번 씩 새로운 트라이로 기존 트라이를 대체
	- 2안) 트라이 각 노드를 개별적으로 갱신
		- 각 노드 검색 후 ancestor 노드를 거슬러 올라가며 연쇄적으로 수정하는 방식
		- 성능이 좋지 않아서 권장하지 않음.
- 검색어 삭제
	- 걸러야 하는 인기 검색어가 있다면 트라이 캐시 앞에 filter layer 를 추가하여 부적절한 질의어가 반환되지 않도록 할 수 있음
![](attatchments/스크린샷%202023-01-31%20오전%208.52.38.png)

### 저장소 규모 확장
- 시작 글자를 기준으로 샤딩하는 방법 추천
- 단, 글자 별로 저장되는 데이터 수가 다르므로 shard map manager 를 두는 것도 좋은 방법
![](attatchments/스크린샷%202023-01-31%20오전%208.56.01.png)
