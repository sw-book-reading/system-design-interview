# 12장 채팅 시스템 설계

<br />

## 개략적 설계안

- 클라이언트로부터 메시지 수신
- 메시지 수신자 결정 및 전달
- 수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관

## 메시지 송신 클라이언트

- sender가 HTTP 요청으로 채팅서비스에 메시지를 보낸다.
- keep-alive 헤더를 사용하면 연결을 끊지 안을수 있어서 효율적이다.

<br />

## 메시지 수신 클라이언트

### 폴링(polling)

- 클라이언트가 주기적으로 서버에게 새 메시지가 있냐고 물어보는 방식
- 단점

  답해줄 메시지가 없는 경우 서버 자원 낭비

<br />

### 롱 폴링(long polling)

- 새 메시지가 반환되거나 타임아웃 될 떄까지 기다리면서 연결을 유지하는 방식
- 새 메시지를 받으면 연결을 종료하고 다시 반복
- 단점
  - 송신하는 쪽과 수신하는 쪽이 같은 서버에 접속하게 되지 않을 수도 있다.
  - 로드밸런싱을 위해 라운드 로빈 알고리즘을 쓸 경우에 위 케이스 발생할 수 있음
  - 메시지를 많이 받지 않는 클라이언트도 타임아웃이 되면 다시 접속할 것이므로 여전히 비효율적이다.

<br />

### 웹소켓(WebSocket)

웹소켓은 서버가 클라이언트에게 비동기 메시지를 보낼때 가장 널리 사용하는 기술

웹소켓 연결은 클라이언트가 시작하고 첫 연결은 HTTP 핸드쉐이크 이용, 이후에는 서버가 클라이언트에게 비동기적으로 메시지를 전송할 수 있다.

HTTP 프로토콜과 다른점은 양방향 통신이 가능하다는 것.

<br />
<br />

## 개략적 설계안

![images_jay_post_3f8d00e0-59e0-401a-8a9b-81ed813bc930_스크린샷 2022-03-02 오후 10 25 28](https://user-images.githubusercontent.com/103870198/215322066-f495b72b-204f-43e7-ace1-4a8415afe85d.png)

### 무상태 서비스

- 로그인,회원가입 등을 처리하는 웹의 보편적인 기능을 제공하는 서비스
- 로드 밸런스 뒤에 붙어있다.

<br />

### 상태 유지 서비스

- 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지하기 위해 필요한 서비스이다.

<br />

### 제 3자 서비스 연동

- 가장 중요한 제3자 서비스는 푸시 알림이다.
- 앱이 실행중이지 않더라도 알림을 받아야 해서다.

<br />

### 규모 확장성

- 동시 접속자가 100만명이라고 할 때 접속당 10k의 서버 메모리가 필요하고, 10GB면 모든 연결을 다 처리할 수 있다.
- 그렇지만 SPOF 를 고려해서 여러 대의 서버로 구성하는것을 고려하자.

<br />
<br />

## 저장소

RDB냐 NoSQL 이냐 어떤 DB를 쓸건지가 중요한데,
고려해야 하는 점은 데이터의 유형과 읽기/쓰기 연산 패턴이다.

채팅 시스템이 다루는 데이터는 두 가지로 나뉜다.

- 사용자 프로필, 설정, 친구 목록 같은 일반적인 데이터는 RDB에 저장한다.
- 채팅 이력과 같은 채팅 시스템에 고유한 데이터

채팅 이력을 어떻게 보관할지 결정하려면 읽기/쓰기 패턴을 이해해야 한다.

- 채팅 이력 데이터의 양은 엄청나다, 페이스북은 매일 600억 개의 메시지를 처리한다.
- 이 데이터 가운데 빈번하게 쓰이는 데이터는 최근 메세지다. 대부분은 오래된 메시지는 들여다 보지 않는다.
- 검색 기능을 사용하거나, 특정 사용자가 언급 된 메시지를 보거나, 특정 메시지로 점프하여 무작위 데이터 접근을 하는 경우도 있다.
- 1:1 채팅 앱의 경우 읽기/쓰기 비율은 1:1 정도이다.

이번 시스템에서는 키-값 저장소를 선택한다.

- 키-값 저장소는 수평적 규모 확장이 쉽다.
- 키-값 저장소는 데이터 접근 지연시간이 낮다.
- RDB는 롱테일에 해당하는 부분을 잘 처리하지 못하는 경향이 있다. 인덱스가 커지면 데이터에 대한 무작위적 접근(random access)를 처리하는 비용이 늘어난다.
- 빅테크 기업이 키-밸류 저장소를 사용해 성공적으로 시스템 운영 중

<br />
<br />

## 데이터 모델

키-값 저장소를 사용하기로 했으니 메시지 데이터를 어떻게 보관할지 살펴보자.

<br />

### 1:1 채팅을 위한 테이블 설계

![images_jay_post_e3404669-bc5c-443c-acb3-1588862bbe28_스크린샷 2022-03-02 오후 11 28 15](https://user-images.githubusercontent.com/103870198/215322864-5782f124-bfbe-4418-8497-c6f8a6a25670.png)

- PK는 message_id, 메시지 순서를 정하는 역할도 함.
- created_at은 서로 다른 두 메시지가 동시에 만들어질 수도 있어서 메시지 순서를 정할 수는 없다.

<br />

### 그룹 채팅을 위한 메시지 테이블

![image (4)](https://user-images.githubusercontent.com/103870198/215322948-61e9f979-59bd-4bc0-b6bb-7a64ab0d1163.png)

- channel_id와 message_id 복합 키 사용

<br />

### 메시지 ID

- message_id는 고유해야 한다.
- ID 값은 정렬 가능해야 하며 시간순과 일치해야 한다.

위 두 조건을 RDB는 auto_increment 쓰면 되지만 NoSQL은 없으므로 스노우플레이크,지역적 순서 번호 생성기 같은 방법을 사용하도록 하자.

<br />
<br />

## 서비스 탐색

- 서비스 탐색은 클라이언트에게 가장 적합한 채팅 서버를 골라 주는 것
- geolocation, 서버의 용량 등을 기준으로 추천

<br />
<br />

## 1:1 채팅 메시지의 처리 흐름

![images_jay_post_7613d271-6751-40f2-8c19-7a060a40d5b8_스크린샷 2022-03-03 오후 9 31 53](https://user-images.githubusercontent.com/103870198/215323173-ab26d747-6568-4919-8cdf-00f07ed8c561.png)

1. 사용자 A가 채팅 서버1로 메시지 전송
2. 채팅 서버 1은 ID 생성기를 사용해 해당 메세지의 ID 결정
3. 채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지가 키-값 저장소에 보관됨
5. (a) 사용자 B가 접속중이면 사용자B가 접속중인 채팅서버2로 메시지 전송, (b) 접속중이 아니면 푸시 알림 메시지를 푸시서버로 보냄
6. 채팅 서버2는 메시지를 사용자 B에게 전송, 사용자 B와 채팅 서버2는 웹소켓 연결 상태이므로 그것을 이용

<br />
<br />

## 여러 단말 사이의 메시지 동기화

![images_jay_post_9d82a1c2-c56a-444f-9cb1-a11a1bd814f4_스크린샷 2022-03-03 오후 9 37 25](https://user-images.githubusercontent.com/103870198/215323349-dce8800f-613f-4d5c-aa00-3691cbbbd313.png)

- 사용자A는 스마트폰과 랩탑 두 대의 단말을 사용중
- 각각의 별도 웹 소켓이 채팅 서버1에 연결되어 있음
- 각 단말은 `cur_max_message_id` 변수를 유지하는데, 해당 단말에서 관측된 가장 최신 메시지의 ID를 추적하는 용도이다.
- 아래 두 조건을 만족하는 메시지는 새 메시지로 간주한다.

  - 수신자 ID가 현재 로그인한 사용자 ID와 같다.
  - 키-값 저장소에 보관된 메시지로서, 그 ID가 cur_max_message_id보다 크다.

  `cur_max_message_id`는 단말마다 별도로 유지 관리하면 되는 값이어서 키-값 저장소에서 새 메시지를 가져오는 동기화 작업도 쉽게 구현할 수 있다.

<br />
<br />

## 소규모 그룹 채팅에서의 메시지 흐름

![images_jay_post_54d16594-9ce6-4ea4-a160-ff01dc48b725_스크린샷 2022-03-03 오후 10 16 38](https://user-images.githubusercontent.com/103870198/215324258-112f60c2-efad-4743-b74c-b8edd444fa96.png)

사용자 A가 그룹채팅방인 채팅서버1에 메시지를 보내면
각각의 사용자 앞에 존재하는 메시지 동기화 큐에 들어간다.

각각의 사용자는 자기 앞에 존재하는 메시지큐(일종의 수신함) 만 확인하면 되니까 동기화 플로우가 단순하다.

그룹이 작으면 메시지를 복사해서 큐에 넣는 작업의 비용이 부담되지 않는다.

<br />
<br />

## 접속 상태 표시

채팅 어플리케이션을 사용하다 보면 사용자 프로필이나 대화명 옆에 접속했다는 표시인 녹색 점을 보게 된다.

이 녹색점을 표시하기 위해 무엇이 필요한지 알아보자.

로그인 시 키-값 저장소에 특정 상태값 online 처리

로그아웃 시 특정 상태값 offline 처리

```ts
User_A = {
  status: true,
  last_active_at: new Date(),
};
```

<br />
<br />

## 접속 장애

짧은 시간동안 인터넷이 끊어졌다 복구되는 현상에 대응할 수 있어야 한다.

heartbeat 검사를 통해 이 문제를 해결하자.

온라인 상태의 클라이언트로 하여금 주기적으로 heartbeat event를 접속상태 서버로 보내고,

마지막 이벤트를 받은 지 x초 이내에 또 다른 heartbeat event 메시지를 받으면

해당 사용자의 접속 상태를 계속 온라인으로 유지하고 아니면 오프라인으로 바꾼다.

<br />
<br />

## 상태 정보의 전송

![images_jay_post_5edeff90-a3ea-4462-8c39-a175ec83fe7e_스크린샷 2022-03-03 오후 11 18 19](https://user-images.githubusercontent.com/103870198/215324964-339a08a7-36f2-4c41-aaf3-d14fb387431e.png)

상태 정보 서버는 발행-구독 모델(publish-subscribe model)을 사용하며, 각각의 친구 관계마다 채널을 하나씩 둔다.

사용자 A의 접속상태가 변경되었다고 하면

- 채널 A-B : B가 구독
- 채널 A-C : C가 구독
- 채널 A-D : D가 구독

이렇게 하면 쉽게 상태 정보변화를 알 수 있다.

이 방식은 그룹의 크기가 작을 때 효과적이며

그룹의 크기가 클 경우 입장하는 순간에만 상태 정보를 읽어가게 하거나, 수동으로 갱신하도록 유도한다.

<br />
<br />

## 마무리

- 클라이언트와 서버 사이의 실시간 통신은 웹소켓을 사용하자.
- 설계에 포함되는 주요 컴포넌트들은 다음과 같다.
  - 채팅 서버
  - 접속 상태 서버
  - 푸시 알림 서버
  - 채팅 이력을 보관하는 키-값 저장소
  - 나머지 기능을 구현할 API 서버
